= Reference:Common XML tags and types

Following document was generated by a modification of http://sourceforge.net/projects/xs3p/[xs3p] stylesheet. It
contains definitions of tags and types used in both geogebra.xml and geogebra_macro.xml files, which are the most
important part of /Reference:File_Format.adoc[GeoGebra file format]. For a brief introduction see
/Reference:Xml.adoc[XML reference].

:toc:

== [#Global_Declarations]#Global Declarations#

=== [#Element:_cascell]#Element: cascell#

XML Instance Representation

[[Element:_cascell_xibox]]
<cascell>

<cellPair> [1..*]

Start /Reference:XML_Glossary.adoc[Sequence] [0..1]

<inputCell> [1]

<xref:/.adoc[expression]> ... </xref:/.adoc[expression]> [1]

</inputCell>

<outputCell> [1]

<xref:/.adoc[expression]> ... </xref:/.adoc[expression]> [1]

</outputCell>

End Sequence

</cellPair>

</cascell>

=== [#Element:_construction]#Element: construction#

XML Instance Representation

[[Element:_construction_xibox]]
<construction

title="xs:string [0..1]"

author="xs:string [0..1]"

date="xs:string [0..1]"

>

Start /Reference:XML_Glossary.adoc[Choice] [0..*]

<command

name="xs:string [1]"

type="xs:string [0..1]"

var="xs:string [0..1]"

> [1]

<casMap> xref:/.adoc[casMap] </casMap> [0..1]

<input> xref:/.adoc[ioType] </input> [1]

<outputSizes> xref:/.adoc[stringVal] </outputSizes> [0..1]

<output> xref:/.adoc[ioType] </output> [1]

</command>

<xref:/.adoc[element]> ... </xref:/.adoc[element]> [1]

<xref:/.adoc[cascell]> ... </xref:/.adoc[cascell]> [1]

<expression

exp="xs:string [0..1]"

label="xs:string [0..1]"

type="xref:/.adoc[elType] [0..1]"

/> [1]

End Choice

</construction>

=== [#Element:_element]#Element: element#

XML Instance Representation

[[Element:_element_xibox]]
<element

type="xref:/.adoc[elType] [0..1]"

label="xs:string [0..1]"

>

Start /Reference:XML_Glossary.adoc[Choice] [0..*]

<absoluteScreenLocation> xref:/.adoc[xyCoords] </absoluteScreenLocation> [0..1]

<allowReflexAngle> xref:/.adoc[boolVal] </allowReflexAngle> [0..1]

<auxiliary> xref:/.adoc[boolVal] </auxiliary> [0..1]

<arcSize> xref:/.adoc[intVal] </arcSize> [0..1]

<animation> xref:/.adoc[animation] </animation> [0..1]

<caption> xref:/.adoc[stringVal] </caption> [0..1]

<comboBox> xref:/.adoc[boolVal] </comboBox> [0..1]

<condition

showObject="xs:string [0..1]"

/> [0..1]

<checkbox

fixed="xs:boolean [0..1]"

/> [0..1]

<coefficients

rep="xref:/.adoc[representation] [0..1]"

data="xref:/.adoc[data] [0..1]"

/> [0..1]

<coords> xref:/.adoc[coords] </coords> [0..1]

<coordStyle

style="xref:/.adoc[coordStyles] [0..1]"

/> [0..1]

<casMap> xref:/.adoc[casMap] </casMap> [0..1]

<decoration

type="xref:/.adoc[decorTypes] [0..1]"

/> [0..1]

<eigenvectors> xref:/.adoc[eigenvectors] </eigenvectors> [0..1]

<emphasizeRightAngle> xref:/.adoc[boolVal] </emphasizeRightAngle> [0..1]

<eqnStyle

style="xref:/.adoc[eqnStyles] [1]"

parameter="xs:string [0..1]"

/> [0..1]

<file

name="xs:string [0..1]"

/> [0..1]

<fixed> xref:/.adoc[boolVal] </fixed> [0..1]

<isShape> xref:/.adoc[boolVal] </isShape> [0..1]

<font> xref:/.adoc[fontProperties] </font> [0..1]

<angleStyle> xref:/.adoc[intVal] </angleStyle> [0..1]

<forceReflexAngle> xref:/.adoc[boolVal] </forceReflexAngle> [0..1]

<ggbscript> xref:/.adoc[stringVal] </ggbscript> [0..1]

<inBackground> xref:/.adoc[boolVal] </inBackground> [0..1]

<interpolate> xref:/.adoc[boolVal] </interpolate> [0..1]

<javascript> xref:/.adoc[stringVal] </javascript> [0..1]

<keepTypeOnTransform> xref:/.adoc[boolVal] </keepTypeOnTransform> [0..1]

<isLaTeX> xref:/.adoc[boolVal] </isLaTeX> [0..1]

<lineStyle

thickness="xref:/.adoc[nonNegInt] [0..1]"

type="xref:/.adoc[lineTypes] [0..1]"

typeHidden="xs:integer [0..1]"

opacity="xs:double [0..1]"

/> [0..1]

<labelMode> xref:/.adoc[intVal] </labelMode> [0..1]

<labelOffset> xref:/.adoc[xyCoords] </labelOffset> [0..1]

<layer> xref:/.adoc[intVal] </layer> [0..1]

<levelOfDetail> xref:/.adoc[intVal] </levelOfDetail> [0..1]

<linkedGeo

exp="xs:string [0..1]"

/> [0..1]

<listType

val="xref:/.adoc[elType] [0..1]"

/> [0..1]

<matrix> xref:/.adoc[matrix] </matrix> [0..1]

<objColor> xref:/.adoc[objColorType] </objColor> [0..1]

<bgColor> xref:/.adoc[rgbaColor] </bgColor> [0..1]

<outlyingIntersections> xref:/.adoc[boolVal] </outlyingIntersections> [0..1]

<pointSize> xref:/.adoc[doubleVal] </pointSize> [0..1]

<fading> xref:/.adoc[doubleVal] </fading> [0..1]

<pointStyle

val="xref:/.adoc[pointStyles] [0..1]"

/> [0..1]

<dimensions

width="xs:double [0..1]"

height="xs:double [0..1]"

/> [0..1]

<embed

id="xs:int [0..1]"

app="xs:string [0..1]"

/> [0..1]

<selectedIndex> xref:/.adoc[intVal] </selectedIndex> [0..1]

<selectionAllowed> xref:/.adoc[boolVal] </selectionAllowed> [0..1]

<show

object="xs:boolean [0..1]"

label="xs:boolean [0..1]"

ev="xref:/.adoc[nonNegInt] [0..1]"

/> [0..1]

<slider> xref:/.adoc[slider] </slider> [0..1]

<slopeTriangleSize> xref:/.adoc[intVal] </slopeTriangleSize> [0..1]

<spreadsheetTrace> xref:/.adoc[spreadsheetTrace] </spreadsheetTrace> [0..1]

<startPoint> xref:/.adoc[expCoords] </startPoint> [0..1]

<tooltipMode

val="xref:/.adoc[tooltipModes] [0..1]"

/> [0..1]

<tags> [0..1]

<tag

key="xs:string [0..1]"

value="xs:string [0..1]"

/> [0..1]

</tags>

<trace> xref:/.adoc[boolVal] </trace> [0..1]

<symbolic> xref:/.adoc[boolVal] </symbolic> [0..1]

<userinput

show="xs:boolean [0..1]"

value="xs:string [0..1]"

valid="xs:boolean [0..1]"

/> [0..1]

<value

val="xref:/.adoc[doubleOrBool] [1]"

random="xs:boolean [0..1]"

/> [0..1]

End Choice

</element>

=== [#Element:_expression]#Element: expression#

XML Instance Representation

[[Element:_expression_xibox]]
<expression

value="xs:string [0..1]"

error="xs:boolean [0..1]"

evalCommand="xs:string [0..1]"

evalComment="xs:string [0..1]"

/>

....
                    ==Global Definitions==
                    
....

=== [#Type:_animation]#Type: animation#

[cols=",",]
|===
|Super-types: |None
|Sub-types: |None
|===

XML Instance Representation

[[Type:_animation_xibox]]
<...

step="xs:string [0..1]"

speed="xs:string [0..1]"

type="xref:/.adoc[nonNegInt] [0..1]"

playing="xs:boolean [0..1]"

/>

=== [#Type:_boolVal]#Type: boolVal#

[cols=",",]
|===
|Super-types: |None
|Sub-types: |None
|===

XML Instance Representation

[[Type:_boolVal_xibox]]
<...

val="xs:boolean [1]"

/>

=== [#Type:_casMap]#Type: casMap#

[cols=",",]
|===
|Super-types: |None
|Sub-types: |None
|===

XML Instance Representation

[[Type:_casMap_xibox]]
<...>

<entry

key="xs:string [0..1]"

val="xs:string [0..1]"

/> [1..*]

</...>

=== [#Type:_coords]#Type: coords#

[cols=",",]
|===
|Super-types: |None
|Sub-types: |None
|===

XML Instance Representation

[[Type:_coords_xibox]]
<...

x="xs:double [0..1]"

y="xs:double [0..1]"

z="xs:double [0..1]"

w="xs:double [0..1]"

ox="xs:double [0..1]"

oy="xs:double [0..1]"

oz="xs:double [0..1]"

ow="xs:double [0..1]"

vx="xs:double [0..1]"

vy="xs:double [0..1]"

vz="xs:double [0..1]"

vw="xs:double [0..1]"

/>

=== [#Type:_doubleVal]#Type: doubleVal#

[cols=",",]
|===
|Super-types: |None
|Sub-types: |None
|===

XML Instance Representation

[[Type:_doubleVal_xibox]]
<...

val="xs:double [1]"

/>

=== [#Type:_eigenvectors]#Type: eigenvectors#

[cols=",",]
|===
|Super-types: |None
|Sub-types: |None
|===

XML Instance Representation

[[Type:_eigenvectors_xibox]]
<...

x0="xs:double [1]"

x1="xs:double [1]"

x2="xs:double [0..1]"

y0="xs:double [1]"

y1="xs:double [1]"

y2="xs:double [0..1]"

z0="xs:double [1]"

z1="xs:double [1]"

z2="xs:double [0..1]"

/>

=== [#Type:_expCoords]#Type: expCoords#

[cols=",",]
|===
|Super-types: |None
|Sub-types: |None
|===

Either exp (for relative start point) or numbers x, y, z (for absolute start point) must be entered. Number parameter is
valid only for image elements and refers to one of the corners (1 to 3)

XML Instance Representation

[[Type:_expCoords_xibox]]
<...

number="xref:/.adoc[nonNegInt] [0..1]"

x="xs:double [0..1]"

y="xs:double [0..1]"

z="xs:double [0..1]"

exp="xs:string [0..1]"

/>

=== [#Type:_fontProperties]#Type: fontProperties#

[cols=",",]
|===
|Super-types: |None
|Sub-types: |None
|===

XML Instance Representation

[[Type:_fontProperties_xibox]]
<...

serif="xs:boolean [0..1]"

size="xref:/.adoc[nonNegInt] [0..1]"

sizeM="xs:double [0..1]"

style="xref:/.adoc[nonNegInt] [0..1]"

/>

=== [#Type:_intVal]#Type: intVal#

[cols=",",]
|===
|Super-types: |None
|Sub-types: |None
|===

XML Instance Representation

[[Type:_intVal_xibox]]
<...

val="xs:int [1]"

/>

=== [#Type:_ioType]#Type: ioType#

[cols=",",]
|===
|Super-types: |None
|Sub-types: |None
|===

XML Instance Representation

[[Type:_ioType_xibox]]
<...

a0="xs:string [0..1]"

a1="xs:string [0..1]"

a2="xs:string [0..1]"

a3="xs:string [0..1]"

a4="xs:string [0..1]"

a5="xs:string [0..1]"

a6="xs:string [0..1]"

a7="xs:string [0..1]"

a8="xs:string [0..1]"

a9="xs:string [0..1]"

a10="xs:string [0..1]"

a11="xs:string [0..1]"

a12="xs:string [0..1]"

a13="xs:string [0..1]"

a14="xs:string [0..1]"

a15="xs:string [0..1]"

a16="xs:string [0..1]"

a17="xs:string [0..1]"

a18="xs:string [0..1]"

a19="xs:string [0..1]"

a20="xs:string [0..1]"

a21="xs:string [0..1]"

a22="xs:string [0..1]"

a23="xs:string [0..1]"

a24="xs:string [0..1]"

a25="xs:string [0..1]"

a26="xs:string [0..1]"

a27="xs:string [0..1]"

a28="xs:string [0..1]"

a29="xs:string [0..1]"

a30="xs:string [0..1]"

a31="xs:string [0..1]"

a32="xs:string [0..1]"

a33="xs:string [0..1]"

a34="xs:string [0..1]"

a35="xs:string [0..1]"

a36="xs:string [0..1]"

a37="xs:string [0..1]"

a38="xs:string [0..1]"

a39="xs:string [0..1]"

a40="xs:string [0..1]"

a41="xs:string [0..1]"

a42="xs:string [0..1]"

a43="xs:string [0..1]"

a44="xs:string [0..1]"

a45="xs:string [0..1]"

a46="xs:string [0..1]"

a47="xs:string [0..1]"

a48="xs:string [0..1]"

a49="xs:string [0..1]"

/>

=== [#Type:_matrix]#Type: matrix#

[cols=",",]
|===
|Super-types: |None
|Sub-types: |None
|===

XML Instance Representation

[[Type:_matrix_xibox]]
<...

A0="xs:double [1]"

A1="xs:double [1]"

A2="xs:double [1]"

A3="xs:double [1]"

A4="xs:double [1]"

A5="xs:double [1]"

A6="xs:double [0..1]"

A7="xs:double [0..1]"

A8="xs:double [0..1]"

A9="xs:double [0..1]"

/>

=== [#Type:_objColorType]#Type: objColorType#

[cols=",",]
|===
|Super-types: |None
|Sub-types: |None
|===

XML Instance Representation

[[Type:_objColorType_xibox]]
<...

r="xref:/.adoc[nonNegInt] [1]"

g="xref:/.adoc[nonNegInt] [1]"

b="xref:/.adoc[nonNegInt] [1]"

dynamicr="xs:string [0..1]"

dynamicg="xs:string [0..1]"

dynamicb="xs:string [0..1]"

dynamica="xs:string [0..1]"

fillType="xref:/.adoc[fills] [0..1]"

colorSpace="xref:/.adoc[colorSpaces] [0..1]"

alpha="xs:double [0..1]"

hatchAngle="xs:double [0..1]"

hatchDistance="xs:double [0..1]"

image="xs:string [0..1]"

inverseFill="xs:boolean [0..1]"

/>

=== [#Type:_rgbColor]#Type: rgbColor#

[cols=",",]
|===
|Super-types: |None
|Sub-types: |None
|===

XML Instance Representation

[[Type:_rgbColor_xibox]]
<...

r="xref:/.adoc[nonNegInt] [1]"

g="xref:/.adoc[nonNegInt] [1]"

b="xref:/.adoc[nonNegInt] [1]"

/>

=== [#Type:_rgbaColor]#Type: rgbaColor#

[cols=",",]
|===
|Super-types: |None
|Sub-types: |None
|===

XML Instance Representation

[[Type:_rgbaColor_xibox]]
<...

r="xref:/.adoc[nonNegInt] [1]"

g="xref:/.adoc[nonNegInt] [1]"

b="xref:/.adoc[nonNegInt] [1]"

alpha="xref:/.adoc[nonNegInt] [0..1]"

/>

=== [#Type:_slider]#Type: slider#

[cols=",",]
|===
|Super-types: |None
|Sub-types: |None
|===

XML Instance Representation

[[Type:_slider_xibox]]
<...

min="xs:string [0..1]"

max="xs:string [0..1]"

width="xs:double [1]"

x="xs:double [1]"

y="xs:double [1]"

fixed="xs:boolean [1]"

absoluteScreenLocation="xs:boolean [0..1]"

horizontal="xs:boolean [1]"

showAlgebra="xs:boolean [0..1]"

/>

=== [#Type:_spreadsheetTrace]#Type: spreadsheetTrace#

[cols=",",]
|===
|Super-types: |None
|Sub-types: |None
|===

XML Instance Representation

[[Type:_spreadsheetTrace_xibox]]
<...

traceColumn1="xs:integer [0..1]"

traceColumn2="xs:integer [0..1]"

traceRow1="xs:integer [0..1]"

traceRow2="xs:integer [0..1]"

tracingRow="xs:integer [0..1]"

numRows="xs:integer [0..1]"

headerOffset="xs:integer [0..1]"

doColumnReset="xs:boolean [0..1]"

doRowLimit="xs:boolean [0..1]"

showLabel="xs:boolean [0..1]"

showTraceList="xs:boolean [0..1]"

doTraceGeoCopy="xs:boolean [0..1]"

/>

=== [#Type:_stringVal]#Type: stringVal#

[cols=",",]
|===
|Super-types: |None
|Sub-types: |None
|===

XML Instance Representation

[[Type:_stringVal_xibox]]
<...

val="xs:string [1]"

/>

=== [#Type:_xyCoords]#Type: xyCoords#

[cols=",",]
|===
|Super-types: |None
|Sub-types: |None
|===

XML Instance Representation

[[Type:_xyCoords_xibox]]
<...

x="xs:double [1]"

y="xs:double [1]"

/>

=== [#Type:_algebraStyles]#Type: algebraStyles#

[cols=",",]
|===
|Super-types: |xs:int < *algebraStyles* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: int

* 0 <= _value_ <= 2

Meaning of values:0=value,1=definition,2=command.

=== [#Type:_angleUnits]#Type: angleUnits#

[cols=",",]
|===
|Super-types: |xs:string < *angleUnits* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: string

* _pattern_ = degree|radiant

=== [#Type:_axisIds]#Type: axisIds#

[cols=",",]
|===
|Super-types: |xs:int < *axisIds* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: int

* 0 <= _value_ <= 2

Meanings of values: 0=x, 1=y, 2=z

=== [#Type:_axisTypes]#Type: axisTypes#

[cols=",",]
|===
|Super-types: |xs:int < *axisTypes* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: int

* 0 <= _value_ <= 15

Meaning of values: bit0 = draw positive arrow, bit1 = bold, bit2 = draw negative arrow, bit3 = fill arrows

=== [#Type:_colorSpaces]#Type: colorSpaces#

[cols=",",]
|===
|Super-types: |xs:int < *colorSpaces* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: int

* 0 <= _value_ <= 2

Meaning of values:0=RGB,1=HSB,2=HSL.

=== [#Type:_coordStyles]#Type: coordStyles#

[cols=",",]
|===
|Super-types: |xs:string < *coordStyles* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: string

* _pattern_ = cartesian|polar|complex

=== [#Type:_data]#Type: data#

[cols=",",]
|===
|Super-types: |xs:string < *data* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: string

* _pattern_ = \[(\[.*\],?)*\]

=== [#Type:_decorTypes]#Type: decorTypes#

[cols=",",]
|===
|Super-types: |xs:int < *decorTypes* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: int

* 0 <= _value_ <= 6

Meanings of values: 0=none, 1=single tick,2=double tick, 3=triple tick, 4=simple arrow, 5=double arrow, 6=triple
arrow.square, 2=dot,3=L (Belgian style).

=== [#Type:_doubleOrBool]#Type: doubleOrBool#

[cols=",",]
|===
|Super-types: |None
|Sub-types: |None
|===

* Union of following types:
** xs:double
** xs:boolean
** xref:/.adoc[specialDouble]
=== [#Type:_elType]#Type: elType#

[cols=",",]
|===
|Super-types: |xs:string < *elType* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: string

* _pattern_ =
(angle|line|plane|point|polygon|polyline|ray|segment|vector|(curve|surface)cartesian|implicit(poly|surface))(3d)?|boolean|button|conic(3d)?(part)?|function(NVar)?|image|list|locus|numeric|quadric(limited|part)?|text(field)?|turtle|net|polyhedron|penstroke|audio|video|embed

=== [#Type:_eqnStyles]#Type: eqnStyles#

[cols=",",]
|===
|Super-types: |xs:string < *eqnStyles* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: string

* _pattern_ = implicit|explicit|specific|parametric

=== [#Type:_fills]#Type: fills#

[cols=",",]
|===
|Super-types: |xs:int < *fills* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: int

* 0 <= _value_ <= 7

Meaning of values:

* 0=STANDARD,
* 1=HATCH,
* 2=CROSSHATCHED,
* 3=CHESSBOARD,
* 4=DOTTED,
* 5=HONEYCOMB,
* 6=BRICK,
* 7=IMAGE

=== [#Type:_gridTypes]#Type: gridTypes#

[cols=",",]
|===
|Super-types: |xs:int < *gridTypes* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: int

* 0 <= _value_ <= 3

Meanings of values: 0=cartesian (major), 1=isometric, 2=polar, 3=cartesian (minor+major)

=== [#Type:_javaDouble]#Type: javaDouble#

[cols=",",]
|===
|Super-types: |xs:string < *javaDouble* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: string

* _pattern_ = Infinity|-Infinity|NaN|(-?[0-9.E]*)

=== [#Type:_lineTypes]#Type: lineTypes#

[cols=",",]
|===
|Super-types: |xs:int < *lineTypes* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: int

* _value_ comes from list: \{'0'|'10'|'15'|'20'|'30'}

Meanings of values: 0=full, 10=dashed short,15=dashed long,20=dotted,30=dashed dotted

=== [#Type:_nonNegInt]#Type: nonNegInt#

[cols=",",]
|===
|Super-types: |xs:integer < *nonNegInt* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: integer

* _value_ >= 0

=== [#Type:_pointCapturings]#Type: pointCapturings#

[cols=",",]
|===
|Super-types: |xs:int < *pointCapturings* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: int

* 0 <= _value_ <= 3

Meanings of values: 0=off, 1=on, 2=on grid,3=automatic.

=== [#Type:_pointStyles]#Type: pointStyles#

[cols=",",]
|===
|Super-types: |xs:int < *pointStyles* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: int

* -1 <= _value_ <= 9

Meanings of values: -1=use global default, 0=full dot, 1=cross, 2=empty dot, 3=plus sign, 4=full diamond, 5=empty
diamond, 6=triangle north, 7=triangle south, 8=triangle east, 9=triangle west.

=== [#Type:_positiveInt]#Type: positiveInt#

[cols=",",]
|===
|Super-types: |xs:integer < *positiveInt* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: integer

* _value_ >= 1

=== [#Type:_representation]#Type: representation#

[cols=",",]
|===
|Super-types: |xs:string < *representation* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: string

* _pattern_ = array

Possible ways for representing coefficients, only 1 possibility in 4.0

=== [#Type:_rightAngleStyles]#Type: rightAngleStyles#

[cols=",",]
|===
|Super-types: |xs:int < *rightAngleStyles* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: int

* 0 <= _value_ <= 3

Meanings of values: 0=none, 1=square, 2=dot,3=L (Belgian style).

=== [#Type:_specialDouble]#Type: specialDouble#

[cols=",",]
|===
|Super-types: |xs:string < *specialDouble* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: string

* _pattern_ = Infinity|-Infinity

=== [#Type:_tickStyles]#Type: tickStyles#

[cols=",",]
|===
|Super-types: |xs:int < *tickStyles* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: int

* 0 <= _value_ <= 2

Meaning of values:0=major minor,1=major,2=none

=== [#Type:_tooltipModes]#Type: tooltipModes#

[cols=",",]
|===
|Super-types: |xs:int < *tooltipModes* (by restriction)
|Sub-types: |None
|===

* Base XSD Type: int

* 0 <= _value_ <= 4
